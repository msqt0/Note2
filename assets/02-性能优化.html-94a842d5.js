import{_ as o,M as c,p as d,q as a,R as e,t as l,N as t,a1 as n}from"./framework-7db056f4.js";const r={},s=e("h1",{id:"性能优化",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#性能优化","aria-hidden":"true"},"#"),l(" 性能优化")],-1),u=e("p",null,"在满足正确性、可靠性、健壮性、可读性等质量因素的前提下，设法提高程序的效率",-1),p=e("h2",{id:"slice-预分配内存",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#slice-预分配内存","aria-hidden":"true"},"#"),l(" slice 预分配内存")],-1),h=e("p",null,[l("在尽可能的情况下，在使用 "),e("code",null,"make()"),l(" 初始化切片时提供容量信息，特别是在追加切片时")],-1),_=e("p",null,"原理",-1),f={href:"https://ueokande.github.io/go-slice-tricks/",target:"_blank",rel:"noopener noreferrer"},m=e("li",null,[e("p",null,"切片本质是一个数组片段的描述，包括了数组的指针，这个片段的长度和容量(不改变内存分配情况下的最大长度)")],-1),b=e("li",null,[e("p",null,"切片操作并不复制切片指向的元素，创建一个新的切片会复用原来切片的底层数组，因此切片操作是非常高效的")],-1),B=e("li",null,[e("p",null,"切片有三个属性，指针(ptr)、长度(len) 和容量(cap)。append 时有两种场景："),e("ul",null,[e("li",null,"当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间"),e("li",null,"当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组")])],-1),g=e("li",null,[e("p",null,"因此，为了避免内存发生拷贝，如果能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能")],-1),x=n('<p>另一个陷阱：大内存得不到释放</p><ul><li><p>在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组</p></li><li><p>因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放</p></li><li><p>推荐的做法，使用 copy 替代 <code>re-slice</code></p></li></ul><h2 id="map-预分配内存" tabindex="-1"><a class="header-anchor" href="#map-预分配内存" aria-hidden="true">#</a> map 预分配内存</h2><ul><li>原理 <ul><li>不断向 map 中添加元素的操作会触发 map 的扩容</li><li>根据实际需求提前预估好需要的空间</li><li>提前分配好空间可以减少内存拷贝和 Rehash 的消耗</li></ul></li></ul><h2 id="使用-strings-builder" tabindex="-1"><a class="header-anchor" href="#使用-strings-builder" aria-hidden="true">#</a> 使用 strings.Builder</h2><p>常见的字符串拼接方式</p><ul><li><code>+</code></li><li><code>strings.Builder</code></li><li><code>bytes.Buffer</code></li></ul><p><code>strings.Builder</code> 最快，<code>bytes.Buffer</code> 较快，<code>+</code> 最慢</p><p>原理</p><ul><li><p>字符串在 Go 语言中是不可变类型，占用内存大小是固定的，当使用 + 拼接 2 个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和</p></li><li><p><code>strings.Builder</code>，<code>bytes.Buffer</code> 的内存是以倍数申请的</p></li><li><p><code>strings.Builder</code> 和 <code>bytes.Buffer</code> 底层都是 <code>[]byte</code> 数组，<code>bytes.Buffer</code> 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 <code>strings.Builder</code> 直接将底层的 <code>[]byte</code> 转换成了字符串类型返回</p></li></ul><h2 id="使用空结构体节省内存" tabindex="-1"><a class="header-anchor" href="#使用空结构体节省内存" aria-hidden="true">#</a> 使用空结构体节省内存</h2><ul><li><p>空结构体不占据内存空间，可作为占位符使用</p></li><li><p>比如实现简单的 Set</p><ul><li>Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。对于集合场景，只需要用到 map 的键而不需要值 <ul><li><code>map[key] = struct{}{}</code></li></ul></li></ul></li></ul><h2 id="使用-atomic-包" tabindex="-1"><a class="header-anchor" href="#使用-atomic-包" aria-hidden="true">#</a> 使用 atomic 包</h2><p>原理</p><ul><li>锁的实现是通过操作系统来实现，属于系统调用，<code>atomic</code> 操作是通过硬件实现的，效率比锁高很多</li><li><code>sync.Mutex</code> 应该用来保护一段逻辑，不仅仅用于保护一个变量</li><li>对于非数值系列，可以使用 <code>atomic.Value</code>，<code>atomic.Value</code> 能承载一个 <code>interface{}</code></li></ul><p>总结</p><ul><li>避免常见的性能陷阱可以保证大部分程序的性能</li><li>针对普通应用代码，不要一味地追求程序的性能，应当在满足正确可靠、简洁清晰等质量要求的前提下提高程序性能</li></ul>',17);function k(y,V){const i=c("ExternalLinkIcon");return d(),a("div",null,[s,u,p,h,_,e("ul",null,[e("li",null,[e("p",null,[e("a",f,[l(" ueokande.github.io/go-slice-tr… "),t(i)])])]),m,b,B,g]),x])}const v=o(r,[["render",k],["__file","02-性能优化.html.vue"]]);export{v as default};
