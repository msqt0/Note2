import{_ as n,p as s,q as t,a1 as a}from"./framework-7db056f4.js";const e={},p=a(`<h1 id="httpservletrequest-对象" tabindex="-1"><a class="header-anchor" href="#httpservletrequest-对象" aria-hidden="true">#</a> HttpServletRequest 对象</h1><p>主要作用是获取Client 发送的各种信息 HttpServletRequest 是 ServletRequest 的子接口, ServletRequest只有一个接口</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>getRequestURL()</td><td>获取 请求行完整URL</td></tr><tr><td>getRequestURI()</td><td>获取 请求行部分URL(资源名称部分,从项目站点名开始，到？前结束)</td></tr><tr><td>getRequestString()</td><td>获取 请求行中的参数部分 从？后开始</td></tr><tr><td>getMethod()</td><td>获取 客户端请求的方式</td></tr><tr><td>getProtocol()</td><td>获取 HTTP 版本号</td></tr><tr><td>getContextPath()</td><td>获取Webapp 名字</td></tr></tbody></table><blockquote><p>以上为常规方法，返回值为Stringbuffer</p></blockquote><br><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><strong>getParameter()</strong></td><td>获取指定名称的参数(重要)</td></tr><tr><td>getParameterValue</td><td>获取指定名称的参数的所有值</td></tr></tbody></table><blockquote><p>以上为特殊方法，返回值为String，getParameterValue 返回字符串数组</p></blockquote><br><h2 id="请求乱码问题" tabindex="-1"><a class="header-anchor" href="#请求乱码问题" aria-hidden="true">#</a> 请求乱码问题</h2><p>由于request接受客户端的参数，所有其默认的语言编码，默认编码为 ISO-8859(此编码不支持中文) 所以会出现乱码，因此需要设置request 的编码，以支持中文。</p><p>两种方式:</p><ol><li>设置request 中的编码方式，告诉服务器以何种方式解析数据</li><li>在接受数据后再通过相应的编码格式还原</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//1.</span>
request<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//只针对post有效</span>

<span class="token comment">//2, 针对Tomcat7及以下GET请求的解决办法</span>
<span class="token class-name">String</span> usrName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">&quot;usrname&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">&quot;ISO-8859-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><ol><li>Tomcat8 get 方法输入的中文不会乱码，post会。</li><li>Tomcat7 及以下 get 方法和 post 方法 都会乱码</li><li>亲测 Tomcat10 post输入中文也不会乱码</li></ol></blockquote><h2 id="请求转发" tabindex="-1"><a class="header-anchor" href="#请求转发" aria-hidden="true">#</a> 请求转发</h2><p>请求转发是一种服务器行为，当客户端请求到达后，服务器会进行转发，此时会将请求对象进行保存，<strong>地址栏中的URL不会改变</strong>，得到响应后，服务端再将响应发送给客户端，<strong>从始至终只有一个请求发出</strong>，达到多个资源协同响应的效果。</p><p>可以让请求从服务器跳转到客户端(或跳转到servlet)</p><p>特点：</p><ol><li>服务端行为</li><li>地址栏不会发生改变</li><li>从始至终只有一个请求</li><li>数据可以共享</li></ol><p>实现:</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// url 为要跳转到的 Servlet 或 html  </span>
<span class="token comment">// 给另一个Servlet 传递request 和 response 对象</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>只能跳转一次，结果会返回，地址栏不变</p></blockquote><h2 id="request-作用域-域对象" tabindex="-1"><a class="header-anchor" href="#request-作用域-域对象" aria-hidden="true">#</a> request 作用域(域对象)</h2><p>通过该对象可以在一个请求中传递数据，作用范围：在一次请求中有效，即服务器跳转有效。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//设置域对象内容</span>
request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Obeject</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//获取域对象内容</span>
request<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//删除域对象内容</span>
request<span class="token punctuation">.</span><span class="token function">removeAttribute</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>request 域对象中的数据在一次请求中有效，即经过请求转发，request域中的数据依然存在，即在请求转发的过程中可以通过request来传输/共享数据。</p><h1 id="httpservletresponse-对象" tabindex="-1"><a class="header-anchor" href="#httpservletresponse-对象" aria-hidden="true">#</a> HttpServletResponse 对象</h1><p>主要功能用于服务器对客户端的请求进行响应，将Web服务器处理后的结果返回客户端。service()方法中形参接受的是 HttpServletResponse接口的实例化对象，这个对象封装了向客户端发送数据，发送响应头，发送响应状态码的方法。</p><h2 id="响应数据" tabindex="-1"><a class="header-anchor" href="#响应数据" aria-hidden="true">#</a> 响应数据</h2><p>接收到客户端请求后，可以通过 HttpServletResponse 对象直接进行响应，响应时需要获取输出流。</p><p>有两种形式:</p><ul><li><strong>getWrite() 获取字符流(只能响应回字符)</strong></li><li><strong>getOutputStream()获取字节流(能响应一切数据)</strong></li></ul><blockquote><p>两者不能同时使用，因为response 对象只能响应一次，响应一次后该对象就消失了。</p></blockquote><p>响应回的数据到客户端被浏览器解析</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>
<span class="token comment">//字符流</span>
<span class="token class-name">PrintWriter</span> writer <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">writer</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
writer<span class="token punctuation">.</span><span class="token function">writer</span><span class="token punctuation">(</span><span class="token string">&quot;&lt;h2&gt;hello&lt;h2&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//字节流</span>
<span class="token class-name">ServletOutputStream</span> out <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token punctuation">.</span><span class="token function">writer</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token punctuation">.</span><span class="token function">writer</span><span class="token punctuation">(</span><span class="token string">&quot;&lt;h2&gt;hello&lt;/h2&gt;&quot;</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="响应乱码问题" tabindex="-1"><a class="header-anchor" href="#响应乱码问题" aria-hidden="true">#</a> 响应乱码问题</h2><p>如果响应数据中含有中文，则很有可能出现乱码问题 ，这是<strong>服务端</strong>和<strong>客户端</strong>的<strong>编码格式不同</strong>造成的。</p><h3 id="getwrite-的字符乱码" tabindex="-1"><a class="header-anchor" href="#getwrite-的字符乱码" aria-hidden="true">#</a> getWrite()的字符乱码</h3><p>对于getWrite()获取到的字符流必定会乱码，由于服务端在进行编码时默认会使用<code>ISO-8859-1</code>格式编码，该编码不支持中文。 要解决这种乱码问题，只能在服务端告知服务器使用一种能支持中文的编码格式，如<code>UTF-8</code>;</p><p>解决:</p><ol><li>设置服务端的编码</li><li>设置客户端的编码</li></ol><blockquote><p>即设置客户端和服务端一致的编码格式，且支持中文</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 单独设置客户端和服务端的编码格式</span>
<span class="token comment">// 在获取输出流前设置服务端编码格式</span>
response<span class="token punctuation">.</span><span class="token function">setCharacterEncoding</span><span class="token punctuation">(</span><span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 设置客户端的编码格式和响应的MINE类型</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;content-type&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;text/html;charset=UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>



<span class="token comment">// 同时设置客户端和服务端的编码格式</span>
response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">&quot;text/html;charset=UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="getoutputstream-字节乱码" tabindex="-1"><a class="header-anchor" href="#getoutputstream-字节乱码" aria-hidden="true">#</a> getOutputStream()字节乱码</h3><p>由于响应的是字节数据，若服务端与客户端编码不一致同样会出现乱码问题，解决方法与上面是一样的，需要同时设置服务端和客户端的编码格式。</p><h2 id="重定向" tabindex="-1"><a class="header-anchor" href="#重定向" aria-hidden="true">#</a> 重定向</h2><p>重定向是一种服务端指导客户端的行为。客户端发出第一个请求被服务器接受处理后，服务器会进行响应，在响应的同时,服务器会给客户端一个新的地址，保存在location中( 下次请求的地址response.sendRedirect(url)),当客户端接收到响应后，会立刻，马上，自动根据服务给的新地址发起第二个请求，服务器接受请求并作出响应，重定向完成</p><p>重定向特点：</p><ol><li>服务端指导，客户端行为</li><li>存在两次请求</li><li>地址栏会发生改变</li><li>request 对象不共享(数据不共享)</li></ol><blockquote><p>如果不是隐私的信息，其实可以使用<code>resp.sendRedirect(url+&quot;?xxx=xx&quot;);</code>的方式在重定向下传输数据</p></blockquote><h1 id="请求转发和重定向的区别" tabindex="-1"><a class="header-anchor" href="#请求转发和重定向的区别" aria-hidden="true">#</a> 请求转发和重定向的区别</h1><p>请求转发和重定向的比较:</p><table><thead><tr><th style="text-align:center;">请求转发(req.getRequestDispatcher().forward(req, resp))</th><th style="text-align:center;">重定向(resp.sendRedirect())</th></tr></thead><tbody><tr><td style="text-align:center;">一次请求，数据在request 域中共享</td><td style="text-align:center;">两次请求， request 域中数据不共享</td></tr><tr><td style="text-align:center;">服务端行为</td><td style="text-align:center;">客户端行为</td></tr><tr><td style="text-align:center;">地址栏不改变</td><td style="text-align:center;">地址栏改变</td></tr><tr><td style="text-align:center;">绝对地址定位到站点后(无法跨域跳转)</td><td style="text-align:center;">绝对地址可写到 http://</td></tr></tbody></table>`,53),o=[p];function c(l,i){return s(),t("div",null,o)}const r=n(e,[["render",c],["__file","02-http请求回应对象.html.vue"]]);export{r as default};
