import{_ as e,p as c,q as d,a1 as o}from"./framework-7db056f4.js";const t={},i=o('<h1 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h1><h2 id="script部分" tabindex="-1"><a class="header-anchor" href="#script部分" aria-hidden="true">#</a> <code>script</code>部分</h2><p><code>export default</code>对象的属性：</p><ul><li><code>name</code>：组件的名称</li><li><code>components</code>：存储<code>&lt;template&gt;</code>中用到的所有组件</li><li><code>props</code>：存储父组件传递给子组件的数据</li><li><code>watch()</code>：当某个数据发生变化时触发</li><li><code>computed</code>：动态计算某个数据</li><li><code>setup(props, context)</code>：初始化变量、函数</li><li><code>ref</code>定义变量，可以用.value 属性重新赋值</li><li><code>reactive</code>定义对象，不可重新赋值</li><li><code>props</code>存储父组件传递过来的数据</li><li><code>context.emit()</code>：触发父组件绑定的函数</li></ul><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref" aria-hidden="true">#</a> ref</h3><p>ref 的作用就是将一个原始数据类型（primitive data type）转换成一个带有响应式特性的数据类型</p><p>ref 的值在 JS/TS 中读取和修改时，需要使用 <code>.value</code> 获取，在模版中读取是，不需要使用 <code>.value</code></p><h3 id="reactive" tabindex="-1"><a class="header-anchor" href="#reactive" aria-hidden="true">#</a> reactive</h3><p>用来创建响应式对象，它接收一个<code>对象/数组</code>参数，返回对象的响应式副本，当该对象的属性值发生变化，会自动更新使用该对象的地方。</p><p>不需要使用 <code>.value</code></p><h3 id="computed" tabindex="-1"><a class="header-anchor" href="#computed" aria-hidden="true">#</a> computed</h3><p>computed 是计算属性的; 它会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来。computed 的值在 getter 执行后是会被缓存的。如果所依赖的数据发生改变时候, 就会重新调用 getter 来计算最新的结果</p><p>computed 设计的初衷是为了使模板中的逻辑运算更简单, 比如在 Vue 模板中有很多复杂的数据计算的话, 我们可以把该计算逻辑放入到 computed 中去计算</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>computed 是基于响应性依赖来进行缓存的。只有在响应式依赖发生改变时它们才会重新求值, 也就是说, 当属性值没有发生改变时, 多次访问 computed 计算属性会立即返回之前缓存的计算结果, 而不会再次执行 computed 中的函数。但是 methods 方法中是每次调用, 都会执行函数的, methods 它不是响应式的</p></div><h3 id="watch" tabindex="-1"><a class="header-anchor" href="#watch" aria-hidden="true">#</a> watch</h3><p>watch 是 vue 内部提供的一个用于侦听功能的更通用的方法，侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数</p><p>vue 官方文档解释当需要在数据变化时执行异步或开销较大的操作时，推荐使用该方法</p><p>参数:</p><ul><li>监听变量</li><li>回调函数</li><li>选项 <ul><li><code>immediate: boolean</code> 第一次是否执行</li><li><code>deep: boolean</code> 监听对象的属性</li></ul></li></ul><h2 id="template部分" tabindex="-1"><a class="header-anchor" href="#template部分" aria-hidden="true">#</a> <code>template</code>部分</h2><ul><li><code>&lt;slot&gt;&lt;/slot&gt;</code>：存放父组件传过来的<code>children</code>。</li><li><code>v-on:click</code>或<code>@click</code>属性：绑定事件</li><li><code>v-if</code>、<code>v-else</code>、<code>v-else-if</code>属性：判断</li><li><code>v-for</code>属性：循环，<code>:key</code>循环的每个元素需要有唯一的<code>key</code></li><li><code>v-bind</code>:或<code>:</code>：绑定属性</li></ul><h2 id="style部分" tabindex="-1"><a class="header-anchor" href="#style部分" aria-hidden="true">#</a> <code>style</code>部分</h2><ul><li><code>&lt;style&gt;</code>标签添加<code>scope</code>属性后，不同组件间的 css 不会相互影响。</li></ul><h2 id="第三方组件" tabindex="-1"><a class="header-anchor" href="#第三方组件" aria-hidden="true">#</a> 第三方组件</h2><ul><li><code>view-router</code>包：实现路由功能。</li><li><code>vuex</code>：存储全局状态，全局唯一。</li><li><code>state</code>: 存储所有数据，可以用<code>modules</code>属性划分成若干模块</li><li><code>getters</code>：根据<code>state</code>中的值计算新的值</li><li><code>mutations</code>：所有对<code>state</code>的修改操作都需要定义在这里，不支持异步，可以通过<code>$store.commit()</code>触发</li><li><code>actions</code>：定义对<code>state</code>的复杂修改操作，支持异步，可以通过<code>$store.dispatch()</code>触发。注意不能直接修改<code>state</code>，只能通过<code>mutations</code>修改<code>state</code>。</li><li><code>modules</code>：定义<code>state</code>的子模块</li></ul>',25),a=[i];function l(r,s){return c(),d("div",null,a)}const p=e(t,[["render",l],["__file","02-基本.html.vue"]]);export{p as default};
