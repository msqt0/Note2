import{_ as e,p as l,q as i,a1 as a}from"./framework-7db056f4.js";const o={},t=a('<h1 id="数据库设计" tabindex="-1"><a class="header-anchor" href="#数据库设计" aria-hidden="true">#</a> 数据库设计</h1><h2 id="设计范式" tabindex="-1"><a class="header-anchor" href="#设计范式" aria-hidden="true">#</a> 设计范式</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>设计数据库时，需要遵循的一些规矩.要遵循后边的范式要求，必须先遵循前边的所有范式要求</p><p>设计关系数据库时，遵循不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据厍冗余越小。</p><h3 id="分类" tabindex="-1"><a class="header-anchor" href="#分类" aria-hidden="true">#</a> 分类</h3><p>目前关系数据库有六种范式：</p><ul><li>第一范式(1NF)</li><li>第二范式(2NF)</li><li>第三范式(3NF)</li><li>巴斯-科德范式(BCNF)</li><li>第四范式(4NF)</li><li>第五范式（5NF 又称完美范式）</li></ul><p><b>第一范式：</b>每一列都是不可分割的原子数据项</p><p><b>第二范式：</b>在 1NF 的基础上，非码属性必须完全依赖于候选码（在 1NF 的基础上消除非主属性对主码的部分函数依赖）</p><p><b>第三范式：</b>在 2Nf 的基础上，任何非主属性不依赖于其他非主属性（在 2NF 的基础上消除传递依赖）</p><h3 id="依赖含义" tabindex="-1"><a class="header-anchor" href="#依赖含义" aria-hidden="true">#</a> 依赖含义</h3><ol><li>函数依赖：<code>A--&gt;B</code>如果通过 A 属性（属性组）的值可以唯一确定 B 属性的值.则称 B 依赖于 A <blockquote><p>例如：学号 --&gt; 姓名</p></blockquote></li><li>完全函数依赖：<code>A--&gt;B</code>如果 A 是一个属性组，则 B 属性值得确定需要依赖 A 属性组中所有的属性值 <blockquote><p>例如：（学号， 课程名称）--&gt; 分数</p></blockquote></li><li>部分函数依赖：<code>A--&gt;B</code>如果 A 是一个属性组，则 B 属性值确定只需要依赖于 A 属性组中的某一些值即可 <blockquote><p>例如：（学号， 课程名称）--&gt; 姓名</p></blockquote></li><li>传递函数依赖：<code>A--&gt;B</code>, <code>B--&gt;C</code> 通过 A 属性（属性组）的值，可以确定唯一 B 属性的值 <blockquote><p>例如：学号--&gt;系名，系名--&gt;系主任</p></blockquote></li><li>如果在在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性值）为该表的码 <blockquote><p>例如：表中码为：（学号，课程名称）</p><ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除了码属性组中的属性</li></ul></blockquote></li></ol>',13),c=[t];function d(r,h){return l(),i("div",null,c)}const p=e(o,[["render",d],["__file","01-数据库设计.html.vue"]]);export{p as default};
