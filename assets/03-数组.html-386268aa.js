import{_ as a,p as n,q as s,a1 as l}from"./framework-7db056f4.js";const i={},e=l(`<h1 id="方法" tabindex="-1"><a class="header-anchor" href="#方法" aria-hidden="true">#</a> 方法</h1><p>方法类似于函数</p><ul><li>方法是解决一类问题的步骤的有序组合，用来完成特定功能的代码片段</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><p>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成一个功能，这样有利于后期的扩展</p><p>方法包含一个<strong>方法头</strong>和一个<strong>方法体</strong></p><ul><li>修饰符：可选，告诉编译器如何调用该方法。定义了该方法的访问类型</li><li>返回值类型：returnValueTtpe</li><li>方法名</li><li>参数类型</li><li>方法体：具体的代码内容</li></ul><h2 id="方法调用" tabindex="-1"><a class="header-anchor" href="#方法调用" aria-hidden="true">#</a> 方法调用</h2><ul><li>调用：对象名.方法名(实参列表)</li><li>java 支持两种调用方法的方式，根据方法是否返回值来选择 <ul><li>有返回值</li><li>无返回值</li></ul></li><li>java 是值传递，传入方法的值会被拷贝</li></ul><h2 id="传参和返回" tabindex="-1"><a class="header-anchor" href="#传参和返回" aria-hidden="true">#</a> 传参和返回</h2><p>java传递参数，和返回 都是通过<strong>复制</strong>的方式</p><p>参数和返回类型</p><ul><li><p>基础类型</p><ul><li>方法内无法修改<strong>普通</strong>的基础类型变量，以及参数</li></ul></li><li><p>引用类型</p><ul><li>方法可以通过复制传递引用的虚拟地址，指向堆中<strong>相同的内存</strong>，但也仅仅能修改该内存，方法外的引用无法修改</li></ul></li></ul><h2 id="方法的重载" tabindex="-1"><a class="header-anchor" href="#方法的重载" aria-hidden="true">#</a> 方法的重载</h2><ul><li>重载就是在一个类中，有相同的名称，但形参不同的方法</li><li>方法的重载规则： <ul><li>方法<strong>名称</strong>必须<strong>相同</strong></li><li><strong>参数</strong>列表必须<strong>不同</strong>(个数不同 或 类型不同 、参数排序顺序不同等)</li><li>方法的返回类型可以相同也可以不同</li><li>仅仅返回类型不同不足以成为方法的重载</li></ul></li><li>理论：方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失效，则编译器报错</li></ul><h2 id="命令行传参" tabindex="-1"><a class="header-anchor" href="#命令行传参" aria-hidden="true">#</a> 命令行传参</h2><p>当需要运行一个程序时，再传递参数，需要依靠main()方法的 <code>String args[]</code>实现</p><blockquote><p>javac 编译</p></blockquote><h2 id="可变参数" tabindex="-1"><a class="header-anchor" href="#可变参数" aria-hidden="true">#</a> 可变参数</h2><ul><li>JDK1.5 开始，java支持传递同类型的可变参数给一个方法</li><li>在方法声明中，在指定参数类型后加一个省略号(...)</li><li>一个方法只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//i为数组</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="递归" tabindex="-1"><a class="header-anchor" href="#递归" aria-hidden="true">#</a> 递归</h2><p>递归结构包含两个部分</p><ul><li>递归头：什么时候不调用自身方法。如果没有头，将会陷入死循环。</li><li>递归体：什么时候需要调用自身方法。</li></ul><blockquote><p>占用栈空间很多</p></blockquote>`,24),t=[e];function o(p,r){return n(),s("div",null,t)}const u=a(i,[["render",o],["__file","03-数组.html.vue"]]);export{u as default};
