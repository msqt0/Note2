import{_ as l,p as i,q as e,a1 as o}from"./framework-7db056f4.js";const r={},c=o('<h1 id="高质量编程" tabindex="-1"><a class="header-anchor" href="#高质量编程" aria-hidden="true">#</a> 高质量编程</h1><ul><li><p>编写的代码能够达到正确可靠、简洁清晰、无性能隐患的目标就能称之为高质量代码</p></li><li><p>实际应用场景千变万化，各种语言的特性和语法各不相同，但是高质量编程遵循的原则是相通的</p></li><li><p>高质量的编程需要注意以下原则：简单性、可读性、生产力</p></li></ul><h2 id="注释" tabindex="-1"><a class="header-anchor" href="#注释" aria-hidden="true">#</a> 注释</h2><ul><li><p>注释应该解释代码作用</p><ul><li>适合注释公共符号</li></ul></li><li><p>注释应该解释代码如何做的</p><ul><li>适合注释方法</li></ul></li><li><p>注释应该解释代码实现的原因</p><ul><li>解释代码的外部因素，github.com/golang/go/b…</li></ul></li><li><p>注释应该解释代码什么情况会出错</p></li><li><p>公共符号始终要注释</p><ul><li>包中声明的每个公共的符号：变量、常量、函数以及结构都需要添加注释</li></ul></li></ul><p>总结:</p><ul><li>代码是最好的注释</li><li>注释应该提供代码未表达出的上下文信息</li></ul><h2 id="命名规范" tabindex="-1"><a class="header-anchor" href="#命名规范" aria-hidden="true">#</a> 命名规范</h2><ul><li><p>variable</p><ul><li>简洁胜于冗长</li><li>缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写</li><li>变量距离其被使用的地方越远，则需要携带越多的上下文信息</li><li>全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义</li></ul></li><li><p>function</p><ul><li>函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的</li><li>函数名尽量简短</li><li>当名为 foo 的包某个函数返回类型 Foo 时，可以省略类型信息而不导致歧义</li><li>当名为 foo 的包某个函数返回类型 T 时（T 并不是 Foo），可以在函数名中加入类型信息</li></ul></li><li><p>package</p><ul><li>只由小写字母组成。不包含大写字母和下划线等字符</li><li>简短并包含一定的上下文信息。例如 schema、task 等</li><li>不要与标准库同名。例如不要使用 sync 或者 strings</li></ul></li></ul><p>总结</p><ul><li>关于命名的大多数规范核心在于考虑上下文</li><li>人们在阅读理解代码的时候也可以看成是计算机运行程序，好的命名能让人把关注点留在主流程上，清晰地理解程序的功能，避免频繁切换到分支细节，增加理解成本</li></ul><h2 id="控制流程" tabindex="-1"><a class="header-anchor" href="#控制流程" aria-hidden="true">#</a> 控制流程</h2><ul><li><p>避免嵌套，保持正常流程清晰</p></li><li><p>如果两个分支中都包含 return 语句，则可以去除冗余的 else</p></li><li><p>尽量保持正常代码路径为最小缩进，优先处理错误情况/特殊情况，并尽早返回或继续循环来减少嵌套，增加可读性</p></li></ul><p>总结</p><ul><li><p>线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支</p></li><li><p>提高代码的可读性</p></li></ul><h2 id="错误和异常处理" tabindex="-1"><a class="header-anchor" href="#错误和异常处理" aria-hidden="true">#</a> 错误和异常处理</h2><ul><li><p>简单错误处理</p><ul><li>优先使用 <code>errors.New</code> 来创建匿名变量来直接表示该错误。有格式化需求时使用 <code>fmt.Errorf</code></li></ul></li><li><p>错误的 <code>Wrap</code> 和 <code>Unwrap</code></p><ul><li>在 <code>fmt.Errorf</code> 中使用 <code>%w</code> 关键字来将一个错误 <code>wrap</code> 至其错误链中</li></ul></li></ul><blockquote><p>Go1.13 在 errors 中新增了三个新 API 和一个新的 format 关键字，分别是 <code>errors.Is</code>、<code>errors.As</code> 、<code>errors.Unwrap</code> 以及 <code>fmt.Errorf</code> 的 <code>%w</code>。如果项目运行在小于 Go1.13 的版本中，导入 golang.org/x/xerrors 来使用。以下语法均已 Go1.13 作为标准。</p></blockquote><ul><li><p>错误判定</p><ul><li>使用 <code>errors.Is</code> 可以判定错误链上的所有错误是否含有特定的错误。</li><li>在错误链上获取特定种类的错误，使用 <code>errors.As</code></li><li><code>errors.Unwrap</code> 调用一次，解开一层包装的 err</li></ul></li><li><p>panic</p><ul><li>不建议在业务代码中使用 panic</li><li>如果当前 goroutine 中所有 deferred 函数都不包含 recover 就会造成整个程序崩溃</li><li>当程序启动阶段发生不可逆转的错误时，可以在 init 或 main 函数中使用 panic</li></ul></li><li><p>recover</p><ul><li>recover 只能在被 defer 的函数中使用，嵌套无法生效，只在当前 goroutine 生效</li><li>如果需要更多的上下文信息，可以 recover 后在 log 中记录当前的调用栈。</li></ul></li></ul><p>总结</p><ul><li><p><code>panic</code> 用于真正异常的情况</p></li><li><p><code>error</code> 尽可能提供简明的上下文信息，方便定位问题</p></li><li><p><code>recover</code> 生效范围，在当前 <code>goroutine</code> 的被 <code>defer</code> 的函数中生效</p></li></ul>',20),d=[c];function p(a,u){return i(),e("div",null,d)}const t=l(r,[["render",p],["__file","01-高质量编程.html.vue"]]);export{t as default};
