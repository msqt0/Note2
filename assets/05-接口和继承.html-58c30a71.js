import{_ as p,M as e,p as o,q as l,R as n,t as s,N as c,a1 as a}from"./framework-7db056f4.js";const i={},u=a(`<h1 id="接口与继承" tabindex="-1"><a class="header-anchor" href="#接口与继承" aria-hidden="true">#</a> 接口与继承</h1><p><strong>接口就像是一种约定</strong>，<strong>实现某个接口，就相当于承诺了某种约定</strong></p><ul><li><p>创建接口关键字：interface</p><ul><li>声明的方法只是一个空方法，没有方法体</li></ul></li><li><p>实现接口关键字：implements</p><ul><li>实现方法体，必须每个方法都实现</li></ul></li></ul><blockquote><p>一个类中当然可以实现多个接口</p><p>在较为复杂的系统中进行大量运用接口，可以条理清晰地把项目组织起来</p></blockquote><h2 id="对象转型" tabindex="-1"><a class="header-anchor" href="#对象转型" aria-hidden="true">#</a> 对象转型</h2><p>通常引用和对象的类型是一样的，即<code>Bad boy = new Bad();</code></p><p>而类型转换讨论的问题是<strong>引用类型和对象类型</strong>不一致的情况下的转换问题</p><p>类型转换有时候会成功，有时候会失败，判断的方法是<strong>把右边的当做左边来用</strong>，是否合理</p><ol><li><p><strong>有继承关系</strong>的类转换</p><ul><li><p>子类转父类(向上转型)</p><ul><li>所有的<strong>子类转换为父类</strong>都是合法的，类似普通变量的类型转换(低转高，自动进行)</li></ul></li><li><p>父类转子类(向下转型)</p><ul><li>父类转子类，有的时候行，有的时候不行，所以必须进行强制转换 <ul><li>父转子可成功，成功转换后该引用无法再当为父来使用</li><li>强制转换失败会抛出<strong>异常</strong></li></ul></li></ul></li></ul></li><li><p><strong>无继承关系</strong>的类转换</p><ul><li>没有继承关系的两个类，互相转换，一定会失败</li></ul></li><li><p><strong>实现类</strong>转换成<strong>接口</strong>(向上转型)</p><ul><li>实现类中一定存在接口中声明的方法，因此，转换是一定成功的</li></ul></li><li><p><strong>接口</strong>转换成<strong>实现类</strong>(向下转型)</p><ul><li>接口中未定义有实现类中的其他方法，因此转换会失败</li></ul></li></ol><blockquote><p><em>注意</em>：类之间的转换如果是赋值形式，且为向下转换(父传子)，如果成功的话，会先将引用指向对象，再转换引用类型，此时转换成功的引用指向的应该为子类，且引用类型也为子类的了</p></blockquote><h2 id="instanceof" tabindex="-1"><a class="header-anchor" href="#instanceof" aria-hidden="true">#</a> instanceof</h2><p><code>A instanceof B</code>判断A是否为B类型，或B的子类</p><h2 id="重写" tabindex="-1"><a class="header-anchor" href="#重写" aria-hidden="true">#</a> 重写</h2><ul><li><p>子类可以继承父类的对象方法，在继承后，重复提供该方法，就叫做方法的重写，又叫覆盖 override</p></li><li><p>子类调用重写的方法调用就会执行重写的方法，而不是从父类的方法</p></li></ul><h2 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h2><ul><li>操作符的多态 <ul><li><code>+</code>可以作为算数运算，也可以作为字符串连接</li></ul></li><li>类的多态 <ul><li>父类引用指向子类对象</li></ul></li></ul><p><strong>类的多态</strong></p><p>都是同一个类型，调用同一个方法，却能呈现不同的状态</p><p>若方法只是有一点区别，只需要定义一个方法，不同的子类重写方法即可适应很多情况，剩下写更多方法的功夫</p><p>条件：</p><ol><li><s>父类(接口)引用指向子类对象</s>只要有继承关系(implements 接口)就可以了</li><li>调用的方法有重写</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i am a man.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Goodman</span> <span class="token keyword">extends</span> <span class="token class-name">Man</span> <span class="token punctuation">{</span>			
     <span class="token keyword">public</span> <span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>					<span class="token comment">//条件2 方法的重写</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i am a good man.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Badman</span> <span class="token keyword">extends</span> <span class="token class-name">Man</span> <span class="token punctuation">{</span>
     <span class="token keyword">public</span> <span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;i am a bad man.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">Man</span> pes1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Goodman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Man</span> pes2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Badman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//条件1 父类引用指向子类</span>
    
    per1<span class="token punctuation">.</span><span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    per2<span class="token punctuation">.</span><span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//实现多态</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>若父类中实现接口，即使子类没有implements也可以重写接口，实现接口多态</p></blockquote><h2 id="隐藏" tabindex="-1"><a class="header-anchor" href="#隐藏" aria-hidden="true">#</a> 隐藏</h2><p>与重写类似，方法的<strong>重写</strong>是子类覆盖父类的<strong>对象方法</strong>，<strong>隐藏</strong>是子类覆盖父类的<strong>类方法</strong></p><blockquote><p>当实例化对象引用为父类，指向子类时，即使子类隐藏了类方法，该对象调用的类方法还是父类的</p></blockquote><h2 id="super" tabindex="-1"><a class="header-anchor" href="#super" aria-hidden="true">#</a> super</h2><p>实例化一个<strong>子类</strong>时，会<strong>先调用</strong>其<strong>父类的构造方法</strong>，再调用其构造方法</p><ul><li><p>子类构造方法会默认调用父类的无参构造方法</p></li><li><p>若父类有带参构造方法，子类的构造方法中使用<code>super(xxx)</code> 可以调用父的带參构造方法</p><ul><li>同理，使用this()调用子类中的有参构造方法</li></ul></li><li><p>使用<code>super.xxx</code>调用父属性</p></li><li><p>使用<code>super.xxx()</code>调用父方法</p></li></ul><blockquote><ol><li><p>父类提供了有参构造方法，系统不会再提供无参构造方法</p></li><li><p>创建子类对象时，会先调用其父类的构造方法，而此时父类没有无参构造，所以需要用super关键字去调用父类的有参构造方法</p></li><li><p>且要写在子类构造方法的前面</p></li></ol></blockquote><h2 id="object类" tabindex="-1"><a class="header-anchor" href="#object类" aria-hidden="true">#</a> Object类</h2>`,31),r=a("<li>Object类是所有类的父类 <ul><li>声明一个类的时候，默认是继承了Object</li></ul></li><li>Object类提供一个toString方法，所以所有的类都有toString方法 <ul><li>toString()的意思是返回当前对象的<strong>字符串表达</strong></li></ul></li><li>当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件当它被垃圾回收的时候，它的finalize() 方法就会被调用。</li><li>equals() 用于判断两个对象的内容是否相同</li><li><code>==</code>用于判断两个引用，是否指向了同一个对象</li><li>hashCode方法返回一个对象的哈希值</li><li>线程同步相关方法 <ul><li>wait()， notify()， notifyAll()</li></ul></li>",7),k={href:"https://how2j.cn/k/reflection/reflection-class/108.html",target:"_blank",rel:"noopener noreferrer"},d=a(`<blockquote><p>finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的，可以重写子类的finalize方法</p></blockquote><h2 id="final" tabindex="-1"><a class="header-anchor" href="#final" aria-hidden="true">#</a> final</h2><p>final修饰类，方法，基本类型变量，引用的时候分别有不同的意思。</p><ul><li><p>修饰类 表示该类不能被继承，其子类会出现编译错误</p></li><li><p>修饰方法 该方法无法被重写</p></li><li><p>修饰基本类型变量 表示该变量只有一次赋值的机会</p></li><li><p>修饰引用 该引用只有1次指向对象的机会</p></li><li><p>修饰常量 指的是可以公开，直接访问，不会变化的值</p></li></ul><h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h2><ul><li><p>在类中声明一个方法，这个方法没有实现体，是一个“空”方法</p></li><li><p>这样的方法就叫抽象方法，使用修饰符“abstract&quot;</p></li><li><p>当一个类有<strong>抽象方法</strong>的时候，该类必须被声明为<strong>抽象类</strong>，并且其<strong>子类</strong>必须提供方法实现</p></li><li><p>抽象类可以没有抽象方法，且抽象类无法被直接实例化，除非在实例化时完成抽象方法</p></li></ul><p>抽象类与接口的区别</p><ol><li>子类只能继承<strong>一个</strong>抽象类，不能继承多个，子类可以实现<strong>多个</strong>接口</li><li>抽象类可以定义public,protected,package,private，静态和非静态属性，final和非final属性，但是接口中声明的属性，只能是public，静态的，final的，即便没有显式的声明</li></ol><blockquote><p><em>注</em>：抽象类和接口类都可以有实体方法。接口中的实体方法叫做默认方法</p></blockquote><h2 id="内部类" tabindex="-1"><a class="header-anchor" href="#内部类" aria-hidden="true">#</a> 内部类</h2><ul><li><p>非静态内部类</p></li><li><p>静态内部类</p></li><li><p>匿名类</p></li><li><p>本地类</p></li></ul><ol><li><strong>非静态内部类 <strong>只有当外部类的</strong>对象</strong>存在，才有意义 <ul><li>即<code>new 外部类().new 内部类();</code> 或 <code>外部对象.new 内部类();</code></li><li>非静态内部类，是可以直接访问外部类的<strong>private</strong>实例属性的</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Littleclas</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Test</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//实例化内部类必须建立在一个外部类对象的基础之上</span>
        <span class="token class-name">Littleclas</span> two <span class="token operator">=</span> one<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Littleclas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><p><strong>静态内部类 <strong>实例化</strong>不需要一个外部类的实例为基础</strong>，可以直接实例化</p><ul><li><p>即<code>new 外部类.静态内部类();</code></p></li><li><p>因为没有一个外部类的实例，所以在静态内部类里面<strong>不可以访问外部类的实例属性和方法</strong></p></li><li><p>除了可以访问外部类的<strong>私有静态成员外</strong>，静态内部类和普通类没什么大的区别</p></li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Littleclas</span> <span class="token punctuation">{</span>		<span class="token comment">//不能访问外部类的实例属性和方法，可以访问私有静态的成员</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Test<span class="token punctuation">.</span>Littleclas</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test<span class="token punctuation">.</span>Littleclas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//实例化静态内部类</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><strong>匿名类 <strong>指的是在</strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练 <ul><li>有的时候，为了快速使用，直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。这样的类，叫做匿名类</li></ul></li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Test</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li><strong>本地类</strong> 可以理解为有名字的匿名类</li></ol><ul><li>内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置</li><li>本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">class</span> <span class="token class-name">Onething</span> <span class="token keyword">extends</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>	<span class="token comment">//与匿名类的区别在于，本地类有了自定义的类名</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        
        <span class="token class-name">Onething</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Onething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><em>注</em>：匿名类中使用外部的局部变量，外部的局部变量必须修饰为final，在jdk8中，已经不需要强制修饰成final了，如果没有写final，不会报错，因为编译器<strong>偷偷的</strong>帮你加上了看不见的final</p></blockquote><h2 id="默认方法" tabindex="-1"><a class="header-anchor" href="#默认方法" aria-hidden="true">#</a> 默认方法</h2><p>默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">What</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">comeOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">default</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saySomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;what&#39;s new?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>同时继承</strong>了多个接口的 <strong>同名默认方法</strong>，就必须在<strong>实现类</strong>中<strong>重写</strong>该方法 从而免去到底调用哪个接口的默认方法这个模棱两可的问题</p><blockquote><p>假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动。但是引入了默认方法后，原来的类，不需要做任何改动，并且还能<strong>得到</strong>这个默认方法通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类</p></blockquote>`,26);function v(m,b){const t=e("ExternalLinkIcon");return o(),l("div",null,[u,n("ul",null,[r,n("li",null,[s("getClass()会返回一个对象的"),n("a",k,[s("类对象"),c(t)]),s("，属于高级内容，不适合初学者过早接触，关于类对象的详细内容请参考反射机制")])]),d])}const h=p(i,[["render",v],["__file","05-接口和继承.html.vue"]]);export{h as default};
