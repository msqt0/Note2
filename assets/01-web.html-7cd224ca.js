import{_ as n,p as s,q as a,a1 as t}from"./framework-7db056f4.js";const e={},p=t(`<h1 id="http-web-编程" tabindex="-1"><a class="header-anchor" href="#http-web-编程" aria-hidden="true">#</a> http/Web 编程</h1><h2 id="简单的-web-服务器" tabindex="-1"><a class="header-anchor" href="#简单的-web-服务器" aria-hidden="true">#</a> 简单的 web 服务器</h2><p>用 go 的 http 包来构建一个简单的 hello world 服务器</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;log&quot;</span>
	<span class="token string">&quot;net/http&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">helloHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	errForm <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> errForm <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Fatalln</span><span class="token punctuation">(</span>errForm<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">)</span>
	<span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Fprint</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">&quot;Hello world 🐈&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	log<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Server start...&quot;</span><span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span> helloHandler<span class="token punctuation">)</span>
	err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">&quot;:8888&quot;</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		log<span class="token punctuation">.</span><span class="token function">Fatalln</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码，要编写一个 Web 服务器很简单，只要调用 http 包的两个函数就可以了。</p><blockquote><p>Go 通过简单的几行代码就已经运行起来一个 Web 服务了，而且这个 Web 服务内部有支持高并发的特性</p></blockquote><h2 id="go-web-如何工作" tabindex="-1"><a class="header-anchor" href="#go-web-如何工作" aria-hidden="true">#</a> Go Web 如何工作</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>Go Web 工作方式的概念</p><ul><li><p>Request：用户请求的信息，用来解析用户的请求信息，包括 post、get、cookie、url 等信息</p></li><li><p>Response：服务器需要反馈给客户端的信息</p></li><li><p>Conn：用户的每次请求链接</p></li><li><p>Handler：处理请求和生成返回信息的处理逻辑</p></li></ul><h3 id="http-包运行机制" tabindex="-1"><a class="header-anchor" href="#http-包运行机制" aria-hidden="true">#</a> Http 包运行机制</h3><table><thead><tr><th>Web 工作模式流程图</th></tr></thead><tbody><tr><td><img src="https://user-images.githubusercontent.com/94043894/184097043-e54bf410-b0d9-4fee-a012-b20a6ea65d58.png" alt="image"></td></tr></tbody></table><ol><li><p>创建 Listen Socket, 监听指定的端口，等待客户端请求到来。</p></li><li><p>Listen Socket 接受客户端的请求，得到 Client Socket, 接下来通过 Client Socket 与客户端通信。</p></li><li><p>处理客户端的请求，首先从 Client Socket 读取 HTTP 请求的协议头，如果是 POST 方法，还可能要读取客户端提交的数据，然后交给相应的 handler 处理请求，handler 处理完毕准备好客户端需要的数据，通过 Client Socket 写给客户端。</p></li></ol><p>这整个的过程里面我们只要了解清楚下面三个问题，也就知道 Go 是如何让 Web 运行起来了</p><ul><li>如何监听端口？</li><li>如何接收客户端请求？</li><li>如何分配 handler？</li></ul><h4 id="listenandserve-监听端口" tabindex="-1"><a class="header-anchor" href="#listenandserve-监听端口" aria-hidden="true">#</a> ListenAndServe（监听端口）</h4><p>通过之前编写的代码可以发现 Go 是通过 <code>ListenAndServe</code> 来处理这些事情的</p><p><b>源码如下：</b></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span> Handler<span class="token punctuation">:</span> handler<span class="token punctuation">}</span>
	<span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化了一个 server 对象，然后调用了该对象 ListenAndServe 方法</p><p><b>源码如下：</b></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> srv<span class="token punctuation">.</span><span class="token function">shuttingDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> ErrServerClosed
	<span class="token punctuation">}</span>
	addr <span class="token operator">:=</span> srv<span class="token punctuation">.</span>Addr
	<span class="token keyword">if</span> addr <span class="token operator">==</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">{</span>
		addr <span class="token operator">=</span> <span class="token string">&quot;:http&quot;</span> <span class="token comment">//http 默认端口：80</span>
	<span class="token punctuation">}</span>
	ln<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">&quot;tcp&quot;</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> srv<span class="token punctuation">.</span><span class="token function">Serve</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ListenAndServe</code>调用了<code>net.Listen(&quot;tcp&quot;, addr)</code>，也就是底层用 TCP 协议搭建了一个服务，最后调用<code>src.Serve</code>监控我们设置的端口。监控之后如何接收客户端的请求呢？</p><h4 id="server-serve-接收客户端请求" tabindex="-1"><a class="header-anchor" href="#server-serve-接收客户端请求" aria-hidden="true">#</a> Server.Serve（接收客户端请求）</h4><p><b>部分源码如下：</b></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Serve</span><span class="token punctuation">(</span>l net<span class="token punctuation">.</span>Listener<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>

	ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>baseCtx<span class="token punctuation">,</span> ServerContextKey<span class="token punctuation">,</span> srv<span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		rw<span class="token punctuation">,</span> err <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token operator">...</span>

		connCtx <span class="token operator">:=</span> ctx
		<span class="token keyword">if</span> cc <span class="token operator">:=</span> srv<span class="token punctuation">.</span>ConnContext<span class="token punctuation">;</span> cc <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
			connCtx <span class="token operator">=</span> <span class="token function">cc</span><span class="token punctuation">(</span>connCtx<span class="token punctuation">,</span> rw<span class="token punctuation">)</span>
			<span class="token keyword">if</span> connCtx <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
				<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">&quot;ConnContext returned nil&quot;</span><span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		tempDelay <span class="token operator">=</span> <span class="token number">0</span>
		c <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">newConn</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span>
		c<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>rwc<span class="token punctuation">,</span> StateNew<span class="token punctuation">,</span> runHooks<span class="token punctuation">)</span> <span class="token comment">// before Serve can return</span>
		<span class="token keyword">go</span> c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span>connCtx<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数里面起了一个<code>for{}</code>，首先通过<code>Listener</code>接收请求：<code>l.Accept()</code>，其次创建一个<code>Conn：c := srv.newConn(rw)</code>，最后单独开了一个<code>goroutine</code>，把这个请求的数据当做参数扔给这个 conn 去服务：<code>go c.serve(connCtx)</code>。这个就是高并发体现了，用户的每一次请求都是在一个新的<code>goroutine</code>去服务，相互不影响。</p><h4 id="conn-serve-处理请求" tabindex="-1"><a class="header-anchor" href="#conn-serve-处理请求" aria-hidden="true">#</a> conn.serve（处理请求）</h4><p><b>部分源码如下：</b></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token function">serve</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>

	ctx<span class="token punctuation">,</span> cancelCtx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span> c<span class="token punctuation">.</span>cancelCtx <span class="token operator">=</span> cancelCtx
	<span class="token keyword">defer</span> <span class="token function">cancelCtx</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	c<span class="token punctuation">.</span>r <span class="token operator">=</span> <span class="token operator">&amp;</span>connReader<span class="token punctuation">{</span>conn<span class="token punctuation">:</span> c<span class="token punctuation">}</span>
	c<span class="token punctuation">.</span>bufr <span class="token operator">=</span> <span class="token function">newBufioReader</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>r<span class="token punctuation">)</span>
	c<span class="token punctuation">.</span>bufw <span class="token operator">=</span> <span class="token function">newBufioWriterSize</span><span class="token punctuation">(</span>checkConnErrorWriter<span class="token punctuation">{</span>c<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token operator">&lt;&lt;</span><span class="token number">10</span><span class="token punctuation">)</span>

	<span class="token keyword">for</span> <span class="token punctuation">{</span>
		w<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">readRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>
        <span class="token operator">...</span>

		<span class="token comment">// HTTP cannot have multiple simultaneous active requests.[*]</span>
		<span class="token comment">// Until the server replies to this request, it can&#39;t read another,</span>
		<span class="token comment">// so we might as well run the handler in this goroutine.</span>
		<span class="token comment">// [*] Not strictly true: HTTP pipelining. We could let them all process</span>
		<span class="token comment">// in parallel even if their responses need to be serialized.</span>
		<span class="token comment">// But we&#39;re not going to implement HTTP pipelining because it</span>
		<span class="token comment">// was never deployed in the wild and the answer is HTTP/2.</span>
		serverHandler<span class="token punctuation">{</span>c<span class="token punctuation">.</span>server<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> w<span class="token punctuation">.</span>req<span class="token punctuation">)</span>
		w<span class="token punctuation">.</span><span class="token function">cancelCtx</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token operator">...</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>conn 首先会解析 request:<code>w, err := c.readRequest(ctx)</code></li><li>然后获取相应的 handler 去处理请求：<code>serverHandler{c.server}.ServeHTTP(w, w.req)</code></li></ul><h4 id="servehttp" tabindex="-1"><a class="header-anchor" href="#servehttp" aria-hidden="true">#</a> ServeHTTP</h4><p><b>部分源码如下：</b></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>sh serverHandler<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw ResponseWriter<span class="token punctuation">,</span> req <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	handler <span class="token operator">:=</span> sh<span class="token punctuation">.</span>srv<span class="token punctuation">.</span>Handler
	<span class="token keyword">if</span> handler <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		handler <span class="token operator">=</span> DefaultServeMux
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> req<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">&quot;*&quot;</span> <span class="token operator">&amp;&amp;</span> req<span class="token punctuation">.</span>Method <span class="token operator">==</span> <span class="token string">&quot;OPTIONS&quot;</span> <span class="token punctuation">{</span>
		handler <span class="token operator">=</span> globalOptionsHandler<span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    <span class="token operator">...</span>
	handler<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>rw<span class="token punctuation">,</span> req<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>sh.srv.Handler</code>就是我们刚才在调用函数<code>ListenAndServe</code>时候的第二个参数，我们前面例子传递的是 nil，也就是为空，那么默认获取<code>handler = DefaultServeMux</code>,那么这个变量用来做什么的呢？对，这个变量就是一个路由器，它用来匹配 url 跳转到其相应的 handle 函数，那么这个我们有设置过吗？有，我们调用的代码里面第一句不是调用了<code>http.HandleFunc(&quot;/&quot;, helloHandle)</code>嘛。这个作用就是注册了请求<code>/</code>的路由规则，当请求 uri 为&quot;/&quot;，路由就会转到函数 helloHandle，DefaultServeMux 会调用 ServeHTTP 方法，这个方法内部其实就是调用 sayhelloName 本身，最后通过写入 response 的信息反馈到客户端。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p><b>详细的整个流程如下图所示：</b></p><table><thead><tr><th>流程图</th></tr></thead><tbody><tr><td><img src="https://user-images.githubusercontent.com/94043894/184104915-4f852d3b-d750-4a98-939c-c643dbe279ee.png" alt="image"></td></tr></tbody></table><h2 id="go-的-http-包详解" tabindex="-1"><a class="header-anchor" href="#go-的-http-包详解" aria-hidden="true">#</a> Go 的 http 包详解</h2><p>Go 的 http 有两个核心功能：Conn、ServeMux</p><h3 id="conn-的-goroutine" tabindex="-1"><a class="header-anchor" href="#conn-的-goroutine" aria-hidden="true">#</a> Conn 的 goroutine</h3><p>与我们一般编写的 http 服务器不同，Go 为了实现高并发和高性能，使用了 goroutines 来处理 Conn 的读写事件，这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。这是 Go 高效的保证。</p><p><b>Go 在等待客户端请求里面是这样写的：</b></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>c<span class="token punctuation">,</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">newConn</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
	<span class="token keyword">continue</span>
<span class="token punctuation">}</span>
<span class="token keyword">go</span> c<span class="token punctuation">.</span><span class="token function">serve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们可以看到客户端的每次请求都会创建一个 Conn，这个 Conn 里面保存了该次请求的信息，然后再传递到对应的 handler，该 handler 中便可以读取到相应的 header 信息，这样保证了每个请求的独立性。</p><h3 id="servemux-的自定义" tabindex="-1"><a class="header-anchor" href="#servemux-的自定义" aria-hidden="true">#</a> ServeMux 的自定义</h3><p>讲述<code>conn.server</code>的时候，其实内部是调用了 http 包默认的路由器，通过路由器把本次请求的信息传递到了后端的处理函数。那么这个路由器是怎么实现的呢？</p><p><b>结构如下：</b></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> ServeMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	mu sync<span class="token punctuation">.</span>RWMutex   <span class="token comment">//锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span>
	m  <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>muxEntry  <span class="token comment">// 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式</span>
	hosts <span class="token builtin">bool</span> <span class="token comment">// 是否在任意的规则中带有 host 信息</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着看一下 Handler 的定义</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>  <span class="token comment">// 路由实现器</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Handler</code> 是一个接口，但是前一小节中的 <code>helloHandler</code> 函数并没有实现 <code>ServeHTTP</code> 这个接口，为什么能添加呢？原来在 http 包里面还定义了一个类型 <code>HandlerFunc</code>,我们定义的函数 helloHandler 就是这个 <code>HandlerFunc</code> 调用之后的结果，这个类型默认就实现了 <code>ServeHTTP</code> 这个接口，即我们调用了 <code>HandlerFunc(f)</code>,强制类型转换 f 成为 <code>HandlerFunc</code> 类型，这样 f 就拥有了 <code>ServeHTTP</code> 方法。</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>

<span class="token comment">// ServeHTTP calls f(w, r).</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>路由器里面存储好了相应的路由规则之后，那么具体的请求又是怎么分发的呢？请看下面的代码，默认的路由器实现了<code>ServeHTTP</code>：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>
<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> r<span class="token punctuation">.</span>RequestURI <span class="token operator">==</span> <span class="token string">&quot;*&quot;</span> <span class="token punctuation">{</span>
		w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">&quot;Connection&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;close&quot;</span><span class="token punctuation">)</span>
		w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>StatusBadRequest<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	h<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> mux<span class="token punctuation">.</span><span class="token function">Handler</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
	h<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所示路由器接收到请求之后，如果是那么关闭链接，不然调用 <code>mux.Handler(r)</code>返回对应设置路由的处理 Handler，然后执行<code>h.ServeHTTP(w, r)</code></p><p>也就是调用对应路由的 handler 的 ServerHTTP 接口，那么 <code>mux.Handler(r)</code>怎么处理的呢？</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>
<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">Handler</span><span class="token punctuation">(</span>r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> r<span class="token punctuation">.</span>Method <span class="token operator">!=</span> <span class="token string">&quot;CONNECT&quot;</span> <span class="token punctuation">{</span>
		<span class="token keyword">if</span> p <span class="token operator">:=</span> <span class="token function">cleanPath</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path <span class="token punctuation">{</span>
			<span class="token boolean">_</span><span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Host<span class="token punctuation">,</span> p<span class="token punctuation">)</span>
			<span class="token keyword">return</span> <span class="token function">RedirectHandler</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> StatusMovedPermanently<span class="token punctuation">)</span><span class="token punctuation">,</span> pattern
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> mux<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Host<span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>mux <span class="token operator">*</span>ServeMux<span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> path <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>h Handler<span class="token punctuation">,</span> pattern <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">defer</span> mux<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// Host-specific pattern takes precedence over generic ones</span>
	<span class="token keyword">if</span> mux<span class="token punctuation">.</span>hosts <span class="token punctuation">{</span>
		h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>host <span class="token operator">+</span> path<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> mux<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
		h<span class="token punctuation">,</span> pattern <span class="token operator">=</span> <span class="token function">NotFoundHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原来他是根据用户请求的 URL 和路由器里面存储的 map 去匹配的，当匹配到之后返回存储的 handler，调用这个 handler 的<code>ServeHTTP</code>接口就可以执行到相应的函数了。</p><p>通过上面这个介绍，我们了解了整个路由过程，Go 其实支持外部实现的路由器 <code>ListenAndServe</code>的第二个参数就是用以配置外部路由器的，它是一个 Handler 接口，即外部路由器只要实现了 Handler 接口就可以，我们可以在自己实现的路由器的<code>ServeHTTP</code>里面实现自定义路由功能。</p><p>如下代码所示，我们自己实现了一个简易的路由器：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;net/http&quot;</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> MyMux <span class="token keyword">struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>MyMux<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path <span class="token operator">==</span> <span class="token string">&quot;/&quot;</span> <span class="token punctuation">{</span>
		<span class="token function">helloHandler</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	http<span class="token punctuation">.</span><span class="token function">NotFound</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
	<span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">helloHandler</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">&quot;Hello myroute!&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	mux <span class="token operator">:=</span> <span class="token operator">&amp;</span>MyMux<span class="token punctuation">{</span><span class="token punctuation">}</span>
	http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">&quot;:9090&quot;</span><span class="token punctuation">,</span> mux<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过对 http 包的分析之后，现在让我们来梳理一下整个的代码执行过程。</p><ul><li><p>首先调用 Http.HandleFunc 按顺序做了几件事：</p><ol><li><p>调用了 DefaultServeMux 的 HandleFunc</p></li><li><p>调用了 DefaultServeMux 的 Handle</p></li><li><p>往 DefaultServeMux 的 <code>map[string]muxEntry</code> 中增加对应的 handler 和路由规则</p></li></ol></li><li><p>其次调用 <code>http.ListenAndServe(&quot;:9090&quot;, nil)</code></p><p>按顺序做了几件事情：</p><ol><li><p>实例化 Server</p></li><li><p>调用 Server 的 <code>ListenAndServe()</code></p></li><li><p>调用 <code>net.Listen(&quot;tcp&quot;, addr)</code>监听端口</p></li><li><p>启动一个 for 循环，在循环体中 Accept 请求</p></li><li><p>对每个请求实例化一个 Conn，并且开启一个 goroutine 为这个请求进行服务 <code>go c.serve()</code></p></li><li><p>读取每个请求的内容 <code>w, err := c.readRequest()</code></p></li><li><p>判断 handler 是否为空，如果没有设置 handler（这个例子就没有设置 handler），handler 就设置为 DefaultServeMux</p></li><li><p>调用 handler 的 ServeHttp</p></li><li><p>在这个例子中，下面就进入到 <code>DefaultServeMux.ServeHttp</code></p></li><li><p>根据 request 选择 handler，并且进入到这个 handler 的 ServeHTTP</p><p><code>mux.handler(r).ServeHTTP(w, r)</code></p></li><li><p>选择 handler：</p><ol><li>判断是否有路由能满足这个 request（哈希表匹配 ServeMux 的 muxEntry）</li><li>如果有路由满足，调用这个路由 handler 的 ServeHTTP</li><li>如果没有路由满足，调用 NotFoundHandler 的 ServeHTTP</li></ol></li></ol></li></ul>`,64),o=[p];function c(l,i){return s(),a("div",null,o)}const r=n(e,[["render",c],["__file","01-web.html.vue"]]);export{r as default};
