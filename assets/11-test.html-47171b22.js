import{_ as e,p as l,q as o,a1 as t}from"./framework-7db056f4.js";const i={},a=t(`<h1 id="http-testandprofiling" tabindex="-1"><a class="header-anchor" href="#http-testandprofiling" aria-hidden="true">#</a> http/TestAndProfiling</h1><h2 id="测试-model-层" tabindex="-1"><a class="header-anchor" href="#测试-model-层" aria-hidden="true">#</a> 测试 Model 层</h2><ul><li><p><code>xxx_test.go</code></p><ul><li>测试代码所在文件的名称以<code>_test</code> 结尾</li><li>对于生产编译，不会包含以<code>_text</code> 结尾的文件</li><li>对于测试编译，会包含以<code>_text</code> 结尾的文件</li></ul></li><li><p><code>func TestUpdateModifiedTime(t *testing.T){...}</code>, 测试函数约定:</p><ul><li>测试函数名以 Test 开头（需要导出)</li><li>函数名需要表达出被验证的特性</li><li>测试函数的参数类型是 <code>*testing.T</code>, 它会提供测试相关的一些工具</li></ul></li></ul><blockquote><p>如果出现错误，使用<code>T.Errorf()</code>等工具抛出，否则测试成功</p></blockquote><p>测试 cli 执行：<code>go test request/model</code></p><h2 id="测试-controller-层" tabindex="-1"><a class="header-anchor" href="#测试-controller-层" aria-hidden="true">#</a> 测试 Controller 层</h2><p>为了尽量保证单元测试的隔离性，测试不要使用例如数据库、外部 API、文件系统等外部资源</p><ul><li>模拟请求和响应</li><li>需要使用<code>net/http/httptest</code>提供的功能</li></ul><h3 id="newrequest-函数" tabindex="-1"><a class="header-anchor" href="#newrequest-函数" aria-hidden="true">#</a> NewRequest 函数</h3><ul><li><code>func NewRequest(method url string, body io.Reader)(*Request, error)</code><ul><li>method: HTTP Method</li><li>url: 请求的 URL</li><li>body: 请求的 body</li><li>返回的 <code>*Request</code> 可以传递给 handler 函数</li></ul></li></ul><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> ResponseRecorder <span class="token punctuation">{</span>
    Code <span class="token builtin">int</span> <span class="token comment">// 状态码</span>
    HeaderMap http<span class="token punctuation">.</span>Header <span class="token comment">// 响应的header</span>
    Body <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer <span class="token comment">// 响应的body</span>
    Flushed <span class="token builtin">bool</span> <span class="token comment">// 缓存是否被flush了</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>用于捕获从 handler 返回的响应，只是做记录</li><li>可以用于测试断言</li></ul><h2 id="profiling-性能分析" tabindex="-1"><a class="header-anchor" href="#profiling-性能分析" aria-hidden="true">#</a> Profiling 性能分析</h2><h3 id="能分析什么" tabindex="-1"><a class="header-anchor" href="#能分析什么" aria-hidden="true">#</a> 能分析什么</h3><ul><li><p>内存消耗</p></li><li><p>CPU 使用</p></li><li><p>阻塞的 goroutine</p></li><li><p>执行追踪</p></li><li><p>还有一个 Web 界面：应用的实时数据</p></li></ul><h3 id="如何分析" tabindex="-1"><a class="header-anchor" href="#如何分析" aria-hidden="true">#</a> 如何分析</h3><p>先在项目中 <code>import _ &quot;net/http/pprof</code></p><p>设置一些监听的 URL,它们会提供各类诊断信息 cli 工具：</p><ul><li><code>go tool pprof http://localhost:8000/debug/pprof/heap</code> 内存 <ul><li>从应用获取内存 dump: 应用在使用哪些内存，它们会去哪</li></ul></li><li><code>go tool pprof http://localhost:8000/debug/pprof/profile</code> CPU <ul><li>CPU 的快照，可以看到谁在用 CPU</li></ul></li><li><code>go tool pprof http://localhost:8000/debug/pprof/block</code> goroutine <ul><li>看到阻塞的 goroutine</li></ul></li><li><code>go tool pprof http://localhost:8000/debug/pprof/trace?secons=5</code> trace <ul><li>监控这段时间内，什么在执行，什么在调用</li></ul></li></ul><p>使用 web 监控 直接打开网址： <code>http://localhost:8000/debug/pprof</code> - 是个快照，只显示刷新页面时的数据</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>为了防止中间件或 handler 与 性能监控冲突，在 goroutine 多开个 server</p><p>假设 web 是这个：<code>http.ListenAndServe(&quot;:8080&quot;, new(middleware.AuthMiddleware))</code>，那么可以启用 8000 端口 <code>go http.ListenAndServe(&quot;:8000&quot;, nil)</code> 专门用来监控</p></div>`,21),n=[a];function d(s,c){return l(),o("div",null,n)}const p=e(i,[["render",d],["__file","11-test.html.vue"]]);export{p as default};
