import{_ as e,p as a,q as n,a1 as s}from"./framework-7db056f4.js";const t={},l=s(`<h1 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h1><p>  事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么<code>同时成功，要么同时失败。</code></p><h2 id="特性" tabindex="-1"><a class="header-anchor" href="#特性" aria-hidden="true">#</a> 特性</h2><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作" aria-hidden="true">#</a> 操作</h2><ol><li>方式一</li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>查看<span class="token operator">/</span>设置事务提交方式 <span class="token number">1</span> 表示自动提交，<span class="token number">0</span> 表示手动提交
<span class="token keyword">select</span> @<span class="token variable">@autocommit</span><span class="token punctuation">;</span>
<span class="token keyword">set</span> @<span class="token variable">@autocommit</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>


提交事务
<span class="token keyword">commit</span><span class="token punctuation">;</span>


回滚事务
<span class="token keyword">rollback</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>方式二</li></ol><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>开启事务
<span class="token keyword">start</span> <span class="token keyword">transaction</span><span class="token punctuation">;</span>  <span class="token operator">or</span> <span class="token keyword">begin</span>

提交事务
<span class="token keyword">commit</span><span class="token punctuation">;</span>


回滚事务
<span class="token keyword">rollback</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="并发事务问题" tabindex="-1"><a class="header-anchor" href="#并发事务问题" aria-hidden="true">#</a> 并发事务问题</h2><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另外一个事务还没有提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了一个幻影</td></tr></tbody></table><h2 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别" aria-hidden="true">#</a> 事务隔离级别</h2><table><thead><tr><th>隔离级别</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td style="text-align:center;">🚫</td><td style="text-align:center;">🚫</td><td style="text-align:center;">🚫</td></tr><tr><td>Read committed</td><td style="text-align:center;">✅</td><td style="text-align:center;">🚫</td><td style="text-align:center;">🚫</td></tr><tr><td>Repeatable Read(mysql默认)</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:center;">🚫</td></tr><tr><td>Serializable</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td><td style="text-align:center;">✅</td></tr></tbody></table><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code> 查看事务隔离级别
<span class="token keyword">select</span> @<span class="token variable">@transaction_isolation</span><span class="token punctuation">;</span>

 设置事务隔离级别
<span class="token keyword">set</span> <span class="token punctuation">[</span><span class="token keyword">session</span><span class="token operator">|</span><span class="token keyword">global</span><span class="token punctuation">]</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> {<span class="token keyword">read</span> uncommited <span class="token operator">|</span> <span class="token keyword">read</span> <span class="token keyword">committed</span> <span class="token operator">|</span> <span class="token keyword">Repeatable</span> <span class="token keyword">read</span> <span class="token operator">|</span> <span class="token keyword">serializable</span>}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>serializable 通过使所有事务串行来达到规避并发问题，即等待第一个操作同一字段的事件结束后才能操作下一个，性能因此下降</p></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>Serialiazble 虽然安全性最高，但是性能最差。同理Read uncommitted 虽然安全性低，但是性能最高, 因此选择时需要合理地考虑需求</p></div>`,16),i=[l];function d(r,c){return a(),n("div",null,i)}const p=e(t,[["render",d],["__file","09-事务.html.vue"]]);export{p as default};
