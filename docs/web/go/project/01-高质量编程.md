# 高质量编程

- 编写的代码能够达到正确可靠、简洁清晰、无性能隐患的目标就能称之为高质量代码

- 实际应用场景千变万化，各种语言的特性和语法各不相同，但是高质量编程遵循的原则是相通的

- 高质量的编程需要注意以下原则：简单性、可读性、生产力

## 注释

- 注释应该解释代码作用

  - 适合注释公共符号

- 注释应该解释代码如何做的

  - 适合注释方法

- 注释应该解释代码实现的原因

  - 解释代码的外部因素，github.com/golang/go/b…

- 注释应该解释代码什么情况会出错

- 公共符号始终要注释
  - 包中声明的每个公共的符号：变量、常量、函数以及结构都需要添加注释

总结:

- 代码是最好的注释
- 注释应该提供代码未表达出的上下文信息

## 命名规范

- variable

  - 简洁胜于冗长
  - 缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写
  - 变量距离其被使用的地方越远，则需要携带越多的上下文信息
  - 全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义

- function

  - 函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的
  - 函数名尽量简短
  - 当名为 foo 的包某个函数返回类型 Foo 时，可以省略类型信息而不导致歧义
  - 当名为 foo 的包某个函数返回类型 T 时（T 并不是 Foo），可以在函数名中加入类型信息

- package
  - 只由小写字母组成。不包含大写字母和下划线等字符
  - 简短并包含一定的上下文信息。例如 schema、task 等
  - 不要与标准库同名。例如不要使用 sync 或者 strings

总结

- 关于命名的大多数规范核心在于考虑上下文
- 人们在阅读理解代码的时候也可以看成是计算机运行程序，好的命名能让人把关注点留在主流程上，清晰地理解程序的功能，避免频繁切换到分支细节，增加理解成本

## 控制流程

- 避免嵌套，保持正常流程清晰

- 如果两个分支中都包含 return 语句，则可以去除冗余的 else

- 尽量保持正常代码路径为最小缩进，优先处理错误情况/特殊情况，并尽早返回或继续循环来减少嵌套，增加可读性

总结

- 线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支

- 提高代码的可读性

## 错误和异常处理

- 简单错误处理

  - 优先使用 `errors.New` 来创建匿名变量来直接表示该错误。有格式化需求时使用 `fmt.Errorf`

- 错误的 `Wrap` 和 `Unwrap`

  - 在 `fmt.Errorf` 中使用 `%w` 关键字来将一个错误 `wrap` 至其错误链中

> Go1.13 在 errors 中新增了三个新 API 和一个新的 format 关键字，分别是 `errors.Is`、`errors.As` 、`errors.Unwrap` 以及 `fmt.Errorf` 的 `%w`。如果项目运行在小于 Go1.13 的版本中，导入 golang.org/x/xerrors 来使用。以下语法均已 Go1.13 作为标准。

- 错误判定

  - 使用 `errors.Is` 可以判定错误链上的所有错误是否含有特定的错误。
  - 在错误链上获取特定种类的错误，使用 `errors.As`
  - `errors.Unwrap` 调用一次，解开一层包装的 err

- panic

  - 不建议在业务代码中使用 panic
  - 如果当前 goroutine 中所有 deferred 函数都不包含 recover 就会造成整个程序崩溃
  - 当程序启动阶段发生不可逆转的错误时，可以在 init 或 main 函数中使用 panic

- recover
  - recover 只能在被 defer 的函数中使用，嵌套无法生效，只在当前 goroutine 生效
  - 如果需要更多的上下文信息，可以 recover 后在 log 中记录当前的调用栈。

总结

- `panic` 用于真正异常的情况

- `error` 尽可能提供简明的上下文信息，方便定位问题

- `recover` 生效范围，在当前 `goroutine` 的被 `defer` 的函数中生效
